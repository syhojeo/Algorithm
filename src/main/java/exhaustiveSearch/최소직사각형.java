package exhaustiveSearch;

/*
    최소직사각형
    문제 설명
    명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

    아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

    명함 번호	가로 길이	세로 길이
    1	60	50
    2	30	70
    3	60	30
    4	80	40
    가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

    모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

    제한사항
    sizes의 길이는 1 이상 10,000 이하입니다.
    sizes의 원소는 [w, h] 형식입니다.
    w는 명함의 가로 길이를 나타냅니다.
    h는 명함의 세로 길이를 나타냅니다.
    w와 h는 1 이상 1,000 이하인 자연수입니다.
    입출력 예
    sizes	result
    [[60, 50], [30, 70], [60, 30], [80, 40]]	4000
    [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]	120
    [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]	133
    입출력 예 설명
    입출력 예 #1
    문제 예시와 같습니다.

    입출력 예 #2
    명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.

    입출력 예 #3
    명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.
 */

/*
    문제 분석
    각 배열에 대한 정렬이 필요해보인다
    배열의 가장 큰값이 큰 배열은 가장 큰값만 기록한 후
    가장 작은 값의 배열을 가장 큰 수부터 비교해가며 가로 세로를 역치 하는 경우 까지 고려하여 최대로 올 수 있는 값을 찾아야한다

    ---------------------------------틀림-----------------------------------------------------
    위와 같이한다면 {70, 60} {50, 70} 같이 두 배열의 최대값이 같은경우 문제가 생긴다
    결국 하나의 배열을 정렬후 다른 한배열만 완전 탐색하는것은 위와같이 최대값이 같은 경우 문제가 발생하게 된다

    때문에
    두 배열 모두 정렬을 할 필요는 없고 이차원 배열의 원소 하나하나 모든 경우의 수를 비교해가며 완전 탐색을 해야 한다
    ---------------------------복잡함--------------------------------------------------------

    다시 생각해보니 쉽다
    sizes 각각의 원소들의 값을 비교하여 sizes[][0]에는 큰값 sizes[][1]에는 작은값을 넣는다
    그후 sizes[][0] 값 기준 정렬, sizes[][1]값 기준 정렬한후
    sizes[][0] * sizes[][1] 을 리턴해주면된다
 */

import java.util.Arrays;

/*
    구체적 설계
    Step1. 가로기준, 세로기준으로 정렬을 한다
    Step2. 가장큰값을 가진 배열(X)을 찾고 그값을 기록
    Step3. 다른 배열(Y)을 완전 탐색하며 배열 (Y) 에서 올 수 있는 최대값을 찾는다
    Step4. 다만 역치를 했을때 값이 역치를 하지 않을때의 값보다 작다면 역치된 작은값을 해당 원소의 값으로 한다

    ---------------------------------틀림-----------------------------------------------------

    Step1. sizes 의 row 값과 column의 최대값을 저장하며 탐색한다
    Step2. 원래 저장된 최대값보다 큰값이 나왔을때는 row와 column값을 최신화 시킨다 (if.1)
    Step3.
    역치에 대한 조건
    1. 최대값보다 현재값이 크면 역치를 해서 값을 확인해봐야한다
    2.1.1 역치를 했을때 역치를 한 값이 현재값과 같거나 작고
    2.1.2 역치로 넘어간 값이 넘어간 치수의 최대값보다 작을 경우 최신화 시키지 않는다
    2.1.3 만약 클 경우에는 역치를 되돌리고 현재값을 최대값으로 지정한다

    2.2.1 역치를 했을떄 역치를 한값이 현재값보다 크다면 역치를 되돌리고 최대값을 최신화시킨다

    Step4. 탐색이 종료되면 row와 column의 값을 곱하여 리턴한다

    60 6
    6  70
    70 5

    ---------------------------복잡함--------------------------------------------------------

    Step1. sizes를 탐색하며 sizes[][0] 과 sizes[][1]을 비교한다
    Step2. 만약 sizes[][1]이 sizes[][0]보다 클경우 스왑한다
    Step3. sizes[][0]기준, sizes[][1] 기준으로 새로 배열을 복사하여 정렬한다
    Step4. 각각 의 배열에서 sizes[0][0] ,sizes[0][1] 을  곱하여 리턴한다

 */
public class 최소직사각형 {

    public int solution(int[][] sizes) {
        int answer = 0;

        //Step1. sizes를 탐색하며 sizes[][0] 과 sizes[][1]을 비교한다
        for (int i = 0; i < sizes.length; i++) {
            //Step2. 만약 sizes[][1]이 sizes[][0]보다 클경우 스왑한다
            if (sizes[i][1] > sizes[i][0]) {
                swap(sizes, i);
            }
        }

        //Step3. sizes[][0]기준, sizes[][1] 기준으로 새로 배열을 복사하여 정렬한다
        int[][] rowSortArrays = sizes.clone();
        int[][] columnSortArrays = sizes.clone();
        Arrays.sort(rowSortArrays, (o1, o2) ->
                o2[0] - o1[0]
        );
        Arrays.sort(columnSortArrays, (o1, o2) ->
                o2[1] - o1[1]
        );

        //Step4. 각각 의 배열에서 sizes[0][0] ,sizes[0][1] 을  곱하여 리턴한다
        return rowSortArrays[0][0] * columnSortArrays[0][1];
    }

    private void swap(int[][] sizes, int i) {

        int temp = sizes[i][0];
        sizes[i][0] = sizes[i][1];
        sizes[i][1] = temp;
    }

    /*
    //다른사람 풀이 ( 내 코드보다 14배 빠르다)
        public int solution(int[][] sizes) {
        int length = 0, height = 0;
        for (int[] card : sizes) {
            length = Math.max(length, Math.max(card[0], card[1]));
            height = Math.max(height, Math.min(card[0], card[1]));
        }
        int answer = length * height;
        return answer;
    }
     */

    /*
        천재다 나는 왜 이런생각을 하지 못했을까..
        문제분석을 오래가져가야하는것인가
        내 풀이 방법을 단 두줄로 압축해버렸다

        Math의 max, min을 중첩하여 값을 도출해냄으로써 정렬을 할 필요가 없도록 코드를 짰다
        이전에도 Math.max, Math.min을 많이 사용하던데 이를 잘 사용해봐야겠다

        for (int[] card : sizes) {
            length = Math.max(length, Math.max(card[0], card[1])); //두수의 최대값과 현재의 최대값을 비교하여 최대값을 도출
            height = Math.max(height, Math.min(card[0], card[1]));  //두수의 최소값과 현재의 최대값을 비교하여 최대값을 도출
        }

        14배차이나는 발상이다
        사실 Math를 안쓴것이 문제가 아니라 이렇게 압축할 수 있다는것을 문제분석 단계에서 생각해내지 못한게 문제였다
        그러나 해결방법을 보면 나와 논리가 같음을 알 수 있는데
        앞으로는 문제분석을 완료한 후 그 방법에 대해서 한번더 압축할 수 있는지에 대해 생각을 해봐야겠다(시간이 남는다면)
     */
}
